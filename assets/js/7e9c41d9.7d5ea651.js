"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[683],{5680:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>g});var r=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=r.createContext({}),l=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=l(e.components);return r.createElement(o.Provider,{value:n},e.children)},_="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),_=l(t),c=i,g=_["".concat(o,".").concat(c)]||_[c]||d[c]||a;return t?r.createElement(g,s(s({ref:n},m),{},{components:t})):r.createElement(g,s({ref:n},m))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,s=new Array(a);s[0]=c;var p={};for(var o in n)hasOwnProperty.call(n,o)&&(p[o]=n[o]);p.originalType=e,p[_]="string"==typeof e?e:i,s[1]=p;for(var l=2;l<a;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},1551:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>p,toc:()=>l});var r=t(9668),i=(t(6540),t(5680));const a={description:"An exploration into making bayer filters but with CMYK instead of RGB.",image:"/img/gallery/2023-12-09_bayer_patterns_cmyk/example1.jpg"},s="2023-12-09 Bayer Pattern CMYK",p={unversionedId:"gallery/2023-12-09_bayer_patterns_cmyk",id:"gallery/2023-12-09_bayer_patterns_cmyk",title:"2023-12-09 Bayer Pattern CMYK",description:"An exploration into making bayer filters but with CMYK instead of RGB.",source:"@site/docs/gallery/2023-12-09_bayer_patterns_cmyk.mdx",sourceDirName:"gallery",slug:"/gallery/2023-12-09_bayer_patterns_cmyk",permalink:"/gcode2dplotterart/docs/gallery/2023-12-09_bayer_patterns_cmyk",draft:!1,editUrl:"https://github.com/TravisBumgarner/gcode2dplotterart/tree/main/gcode2dplotterart-website/docs/gallery/2023-12-09_bayer_patterns_cmyk.mdx",tags:[],version:"current",frontMatter:{description:"An exploration into making bayer filters but with CMYK instead of RGB.",image:"/img/gallery/2023-12-09_bayer_patterns_cmyk/example1.jpg"},sidebar:"tutorialSidebar",previous:{title:"2023-12-06 Happy Little Accident",permalink:"/gcode2dplotterart/docs/gallery/2023-12-06_happy_little_accident"},next:{title:"2025-01-18 Diagonal Lines",permalink:"/gcode2dplotterart/docs/gallery/2025_01_18_diagonal_lines"}},o={},l=[{value:"Description",id:"description",level:2},{value:"Images",id:"images",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Plotter Preview",id:"plotter-preview",level:2},{value:"Code",id:"code",level:2}],m={toc:l},_="wrapper";function d(e){let{components:n,...a}=e;return(0,i.yg)(_,(0,r.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"2023-12-09-bayer-pattern-cmyk"},"2023-12-09 Bayer Pattern CMYK"),(0,i.yg)("h2",{id:"description"},"Description"),(0,i.yg)("p",null,"An exploration into making ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bayer_filter"},"bayer filters")," but with CMYK instead of RGB."),(0,i.yg)("h2",{id:"images"},"Images"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"example of plotted code",src:t(753).A,width:"1080",height:"1095"})),(0,i.yg)("h2",{id:"inputs"},"Inputs"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"preview screenshot",src:t(5214).A,width:"1000",height:"1000"})),(0,i.yg)("h2",{id:"plotter-preview"},"Plotter Preview"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"preview screenshot",src:t(6356).A,width:"878",height:"830"})),(0,i.yg)("h2",{id:"code"},"Code"),(0,i.yg)("admonition",{type:"warning"},(0,i.yg)("p",{parentName:"admonition"},"This code may or may not run and is intended more as a reference. Additionally, it was most likely not written with the latest version of the library. To ensure compatibility, check the date of this post against the ",(0,i.yg)("a",{parentName:"p",href:"https://pypi.org/project/gcode2dplotterart/#history"},"version history")," and install the corresponding version.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'from gcode2dplotterart import Plotter2D\nimport cv2\nfrom typing import List, Tuple\nfrom random import shuffle\nimport time\nimport math\nimport imutils\nimport numpy as np\nfrom scipy.cluster.vq import kmeans, vq\n\nplotter = Plotter2D(\n    title="CMYK Bayer Patterns",\n    x_max=160,\n    x_min=0,\n    y_max=160,\n    y_min=0,\n    feed_rate=10000,\n    include_comments=False,\n)\n\nLINE_WIDTH = 2.5  # mm\n\nCYAN_LAYER = "cyan"\nMAGENTA_LAYER = "magenta"\nYELLOW_LAYER = "yellow"\nBLACK_LAYER = "black"\nWHITE_LAYER = "white"\n\n\ndef bgr_to_cmyk(bgr_color):\n    b, g, r = [x / 255.0 for x in bgr_color]\n\n    c = 1 - r\n    m = 1 - g\n    y = 1 - b\n\n    k = min(c, m, y)\n\n    c = (c - k) / (1 - k) if 1 - k != 0 else 0\n    m = (m - k) / (1 - k) if 1 - k != 0 else 0\n    y = (y - k) / (1 - k) if 1 - k != 0 else 0\n\n    c, m, y, k = [round(x * 100) for x in (c, m, y, k)]\n\n    return c, m, y, k\n\n\nLAYERS = [CYAN_LAYER, MAGENTA_LAYER, YELLOW_LAYER, BLACK_LAYER, WHITE_LAYER]\n\nfor layer in LAYERS:\n    plotter.add_layer(title=layer, color=layer, line_width=LINE_WIDTH)\n\n\ndef kmeans_algorithm(pixels, k=1):\n    # Convert the pixel array to a NumPy array\n    pixel_array_np = np.array(pixels)\n\n    # Flatten the array to 1D for kmeans\n    flattened_array = pixel_array_np.reshape(-1, 4)\n\n    centroids, _ = kmeans(flattened_array.astype(float), k)\n\n    # Assign each pixel to the nearest centroid\n    labels, _ = vq(flattened_array, centroids)\n\n    # Calculate the average CMYK for each cluster\n    average_cmyk_colors = [\n        tuple(np.mean(flattened_array[labels == i], axis=0).astype(int))\n        for i in range(k)\n    ]\n\n    return average_cmyk_colors[0]\n\n\ndef sample_img_and_get_cmyk_ratio(sample_square, pixels_per_sample_side):\n    if sample_square.shape != (pixels_per_sample_side, pixels_per_sample_side, 4):\n        raise ValueError(\n            f"Input sample must be a {pixels_per_sample_side}x{pixels_per_sample_side} square with 4 color channels."\n        )\n\n    cmyk_value = kmeans_algorithm(sample_square, k=3)\n\n    # This ratio calculation might be incorrect.\n    cmyk_ratios = [value / sum(cmyk_value) * 100 for value in cmyk_value]\n    return {\n        CYAN_LAYER: cmyk_ratios[0],\n        MAGENTA_LAYER: cmyk_ratios[1],\n        YELLOW_LAYER: cmyk_ratios[2],\n        BLACK_LAYER: cmyk_ratios[3],\n    }\n\n\ndef read_and_prep_image(\n    filename: str,\n    pixels_per_sample_side: int,\n    resize_percent: float = 1.0,\n) -> List[List[Tuple[int, int, int]]]:\n    """\n    Resize the image such that the side lengths are divisible by the number of pixels that will be used to represent each dot.(pixels_per_sample)\n\n    Params:\n      filename: The name of the image file to read in.\n      pixels_per_sample_side: the number of pixels, along a side to sample. Used to round the image size such that samples per side becomes an int\n      resize_percent: Whether or not to resize the image. If true, the image will be resized to the specified percentage of the original image size.\n    """\n\n    img = cv2.imread(filename)  # Reads in image as BGR\n    print("original image shape", img.shape)\n    if pixels_per_sample_side > img.shape[0] or pixels_per_sample_side > img.shape[1]:\n        raise ValueError("pixels_per_sample_side must be less than the image size")\n\n    img = imutils.resize(img, width=int(img.shape[1] * resize_percent))\n\n    rounded_width = int(\n        math.floor(img.shape[0] / pixels_per_sample_side) * pixels_per_sample_side\n    )\n    rounded_height = int(\n        math.floor(img.shape[1] / pixels_per_sample_side) * pixels_per_sample_side\n    )\n\n    # Resize expects width, height unlike in just about every other place.\n    img = cv2.resize(img, (rounded_width, rounded_height))\n    print("rounded image shape", img.shape)\n\n    img = np.apply_along_axis(bgr_to_cmyk, 2, img)\n    print("converted bgr to cmyk")\n    return img\n\n\ndef image_to_cmyk_color_ratios(\n    img: List[List[Tuple[int, int, int]]], pixels_per_sample_side: int\n):\n    """\n    Take in an image, and return a 2D list of colors to plot as output.\n\n    Params:\n      img: The image to process\n      pixels_per_sample_side: the number of pixels, along a side to sample. The number of pixels would then be pixels_per_sample_side**2.\n    """\n\n    output = []\n\n    for starting_col in range(0, len(img[0]), pixels_per_sample_side):\n        output_row = []\n        for starting_row in range(0, len(img), pixels_per_sample_side):\n            img_section = img[\n                starting_row : starting_row + pixels_per_sample_side,\n                starting_col : starting_col + pixels_per_sample_side,\n            ]\n            cmyk_ratio = sample_img_and_get_cmyk_ratio(\n                img_section, pixels_per_sample_side\n            )\n            output_row.append(cmyk_ratio)\n        # Plotting is done from the bottom left corner, so we need to reverse the order of the rows.\n        output.append(output_row)\n\n    return output\n\n\ndef plot_points_per_cmyk_ratio(\n    cmyk_ratio,\n    x_start_mm,\n    y_start_mm,\n    mm_per_sample_side,\n    points_per_sample_side,\n):\n    points = []\n    for color, percentage in cmyk_ratio.items():\n        num_points = int(percentage / 100 * points_per_sample_side**2)\n        for i in range(num_points):\n            points.append(color)\n\n    # Need to handle the situation where the number of points is less than the number of points per sample side.\n    # One such way this occurs is if the points_per_sample_side is odd.\n    filtered_dict = {k: v for k, v in cmyk_ratio.items() if v != 0}\n    # Sort the dictionary by values in descending order\n    cmyk_ratio_keys = list(\n        dict(\n            sorted(filtered_dict.items(), key=lambda item: item[1], reverse=True)\n        ).keys()\n    )\n\n    current_index = 0\n    while len(points) < points_per_sample_side**2:\n        # White is the only color where all the percentages are 0.\n        if len(cmyk_ratio_keys) == 0:\n            points.append("white")\n            continue\n\n        points.append(cmyk_ratio_keys[current_index % len(cmyk_ratio_keys)])\n        current_index += 1\n\n    shuffle(points)\n\n    x_spacing = mm_per_sample_side / points_per_sample_side\n    y_spacing = mm_per_sample_side / points_per_sample_side\n\n    for i in range(points_per_sample_side):\n        for j in range(points_per_sample_side):\n            x = x_start_mm + i * x_spacing\n            y = y_start_mm + j * y_spacing\n            plot_color = points.pop()\n\n            plotter.layers[plot_color].add_point(\n                x=x,\n                y=y,\n            )\n\n\ndef main():\n    filename = "./desktop.png"\n\n    # The number of pixels to sample along a side of the image. If an image is 100x100, and pixels_per_sample_side is 10, then there will be 10x10 samples.\n    pixels_per_sample_side = 15\n\n    # The number of points to plot per sample. If points_per_sample_side is 2, then there will be 4 points per sample.\n    # The higher the number of points per sample, the more accurate the color will be, but the longer it will take to plot.\n    points_per_sample_side = 2\n\n    # Resize image to render faster, useful for testing\n    resize_percent = 1\n\n    # ========================================================================================================\n    # Don\'t modify anything below these lines\n    # ========================================================================================================\n\n    start_time = time.time()\n\n    # It is useful to set the resize_percent to a lower number while iterating\n    img = read_and_prep_image(\n        filename, pixels_per_sample_side, resize_percent=resize_percent\n    )\n    [rows, columns, color_channels] = img.shape\n    print(img[0][0])\n    width_samples = rows / pixels_per_sample_side\n    height_samples = columns / pixels_per_sample_side\n\n    print("width samples", width_samples)\n    print("height samples", height_samples)\n\n    mm_per_sample_width = plotter.width / width_samples\n    mm_per_sample_height = plotter.height / height_samples\n\n    print("mm per sample width", mm_per_sample_width)\n    print("mm per sample height", mm_per_sample_height)\n\n    # To maintain an aspect ratio and have all points fit on the canvas, we need to use the smaller of the two mm_per_sample values.\n    mm_per_sample_side = min(mm_per_sample_width, mm_per_sample_height)\n    print("mm", mm_per_sample_side)\n    cmyk_color_ratios = image_to_cmyk_color_ratios(\n        img, pixels_per_sample_side=pixels_per_sample_side\n    )\n\n    for row_index, row in enumerate(cmyk_color_ratios):\n        for col_index, cmyk_ratio in enumerate(row):\n            x_start_mm = col_index * mm_per_sample_side\n            y_start_mm = row_index * mm_per_sample_side\n            plot_points_per_cmyk_ratio(\n                cmyk_ratio=cmyk_ratio,\n                x_start_mm=x_start_mm,\n                y_start_mm=y_start_mm,\n                mm_per_sample_side=mm_per_sample_side,\n                points_per_sample_side=points_per_sample_side,\n            )\n\n    end_time = time.time()\n    print(f"Total time: {end_time - start_time}")\n    plotter.preview()\n    plotter.save()\n\n\nif __name__ == "__main__":\n    main()\n\n')))}d.isMDXComponent=!0},753:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/example1-a0dc399ada3d3e64711dfce2d4795d49.jpg"},6356:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/preview-82034c731a65933c29864d20b0fa4e46.png"},5214:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/preview0-d4086d5c6989baa19f7202a705b42e2b.png"}}]);