"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6865],{147:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/preview-3041c1a43a511c65623b6ccad17ba507.png"},1314:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>_});const o=JSON.parse('{"id":"gallery/2023-10-05_roaming_rectangles","title":"2023-10-05 Roaming Rectangles","description":"Series of rectangles where one is connected to the next one, of varying colors and sizes.","source":"@site/docs/gallery/2023-10-05_roaming_rectangles.mdx","sourceDirName":"gallery","slug":"/gallery/2023-10-05_roaming_rectangles","permalink":"/gcode2dplotterart/docs/gallery/2023-10-05_roaming_rectangles","draft":false,"unlisted":false,"editUrl":"https://github.com/TravisBumgarner/gcode2dplotterart/tree/main/gcode2dplotterart-website/docs/gallery/2023-10-05_roaming_rectangles.mdx","tags":[],"version":"current","frontMatter":{"description":"Series of rectangles where one is connected to the next one, of varying colors and sizes.","image":"/img/gallery/2023-10-05_roaming_rectangles/example1.jpg"},"sidebar":"tutorialSidebar","previous":{"title":"2023-07-15 Bunch of Lines","permalink":"/gcode2dplotterart/docs/gallery/2023-07-15_bunch_of_lines"},"next":{"title":"2023-11-15 Image Lines","permalink":"/gcode2dplotterart/docs/gallery/2023-11-15_image_lines"}}');var r=n(4848),i=n(8453);const a={description:"Series of rectangles where one is connected to the next one, of varying colors and sizes.",image:"/img/gallery/2023-10-05_roaming_rectangles/example1.jpg"},s="2023-10-05 Roaming Rectangles",l={},_=[{value:"Description",id:"description",level:2},{value:"Images",id:"images",level:2},{value:"Plotter Preview",id:"plotter-preview",level:2},{value:"Code",id:"code",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"2023-10-05-roaming-rectangles",children:"2023-10-05 Roaming Rectangles"})}),"\n",(0,r.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,r.jsx)(t.p,{children:"Series of rectangles where one is connected to the next one, of varying colors and sizes."}),"\n",(0,r.jsx)(t.h2,{id:"images",children:"Images"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"example of plotted code",src:n(6989).A+"",width:"1600",height:"1147"}),"\n",(0,r.jsx)(t.img,{alt:"example of plotted code",src:n(7090).A+"",width:"1600",height:"1075"})]}),"\n",(0,r.jsx)(t.h2,{id:"plotter-preview",children:"Plotter Preview"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"preview screenshot",src:n(147).A+"",width:"640",height:"480"})}),"\n",(0,r.jsx)(t.h2,{id:"code",children:"Code"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["This code may or may not run and is intended more as a reference. Additionally, it was most likely not written with the latest version of the library. To ensure compatibility, check the date of this post against the ",(0,r.jsx)(t.a,{href:"https://pypi.org/project/gcode2dplotterart/#history",children:"version history"})," and install the corresponding version."]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"from random import randint, choice\nfrom gcode2dplotterart import Plotter2D\n\nBLACK_LAYER = 'thin_black'\nCOLOR_LAYERS=['thick_red', 'thick_yellow', 'thick_blue']\n\nplotter = Plotter2D(\n  title=\"Roaming Rectangles\",\n  x_min = 0,\n  x_max = 220,\n  y_min = -150, # Note - My plotting goes from -150 to 0.\n  y_max = 0,\n  feed_rate=10000,\n  output_directory=\"./output\",\n  handle_out_of_bounds='Warning' # Some points will be out of bounds for this, that's ok.\n)\n\nfor layer in COLOR_LAYERS:\n  plotter.add_layer(layer)\nplotter.add_layer(BLACK_LAYER)\n\n# Min movement is 10% of the total width/height\nMIN_MOVEMENT_X = round((plotter.x_max - plotter.x_min) * 0.10)\nMIN_MOVEMENT_Y = round((plotter.y_max - plotter.y_min) * 0.10)\n\n# Max movement is 20% of the total width/height\nMAX_MOVEMENT_X = round((plotter.x_max - plotter.x_min) * 0.20)\nMAX_MOVEMENT_Y = round((plotter.y_max - plotter.y_min) * 0.20)\n\ndef calculate_next_move(start_point, end_point):\n  # Don't start the next rectangle where the current rectangle started, don't include (start_point[0], start_point[1])\n  next_point_start_options = [\n    (start_point[0], end_point[1]),\n    (end_point[0], start_point[1]),\n    (end_point[0], end_point[1]),\n  ]\n\n  next_point_start = choice(next_point_start_options)\n\n  # Future improvement - Could optimize here so that choice([-1,1]) factors in the previous rectangle and doesn't plot on top.\n  movement_x = randint(MIN_MOVEMENT_X, MAX_MOVEMENT_X) * choice([-1, 1])\n  movement_y = randint(MIN_MOVEMENT_Y, MAX_MOVEMENT_Y) * choice([-1, 1])\n\n  next_point_end = (next_point_start[0] + movement_x, next_point_start[1] + movement_y)\n\n  return [next_point_start, next_point_end]\n\n# Starting rectangle is a rectangle plotted around the center point.\nCENTER_POINT = [(plotter.x_max + plotter.x_min) / 2, (plotter.y_max + plotter.y_min) / 2]\nstart_point = [CENTER_POINT[0] - plotter.width * 0.05, CENTER_POINT[1] - plotter.height * 0.05]\nend_point = [CENTER_POINT[0] + (plotter.x_max - plotter.x_min) * 0.05, CENTER_POINT[1] + (plotter.y_max - plotter.y_min) * 0.05 ]\n\ncurrent_layer_index = 0\nplotter.layers[COLOR_LAYERS[current_layer_index]].add_rectangle(start_point[0], start_point[1], end_point[0], end_point[1])\nplotter.layers[BLACK_LAYER].add_rectangle(start_point[0], start_point[1], end_point[0], end_point[1])\n\nTOTAL_RECTANGLES = 100\ncurrent_rectangle_count = 0\n\nwhile True:\n  # With 3 colors being plotted, the next rectangle plotted should not be the same color as the previous.\n  current_layer_index_choices = [index for [index, value] in enumerate(COLOR_LAYERS) if index != current_layer_index]\n  current_layer_index = choice(current_layer_index_choices)\n\n  while True:\n    # Lazy solution to prevent plotter from going out of bounds\n    [next_start_point, next_end_point] = calculate_next_move(start_point, end_point)\n    if plotter.is_point_in_bounds(next_start_point[0], next_start_point[1]) and plotter.is_point_in_bounds(next_end_point[0], next_end_point[1]):\n      break\n\n  plotter.layers[COLOR_LAYERS[current_layer_index]].add_rectangle(next_start_point[0], next_start_point[1], next_end_point[0], next_end_point[1])\n  plotter.layers[BLACK_LAYER].add_rectangle(next_start_point[0], next_start_point[1], next_end_point[0], next_end_point[1])\n  start_point = next_start_point\n  end_point = next_end_point\n  \n  current_rectangle_count += 1\n  if current_rectangle_count == TOTAL_RECTANGLES:\n    break\n\nplotter.preview()\nplotter.save()\n"})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},6989:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/example1-53389bb1cc21dc7a9aba3a302f04e952.jpg"},7090:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/example2-49560dc8cf00bced638bb5df56e3977e.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var o=n(6540);const r={},i=o.createContext(r);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);